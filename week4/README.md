## Week 4 Overview

* [DE Zoomcamp 4.1.1 - Analytics Engineering Basics](#de-zoomcamp-411---analytics-engineering-basics)
* [DE Zoomcamp 4.1.2 - What is dbt](#de-zoomcamp-412---what-is-dbt)
* [DE Zoomcamp 4.2.1 - Start Your dbt Project: BigQuery and dbt Cloud](#de-zoomcamp-421---start-your-dbt-project-bigquery-and-dbt-cloud)
* [DE Zoomcamp 4.3.1 - Build the First dbt Models](#de-zoomcamp-431---build-the-first-dbt-models)

## [DE Zoomcamp 4.1.1 - Analytics Engineering Basics](https://www.youtube.com/watch?v=uF76d5EmdtU&list=PL3MmuxUbc_hJed7dXYoJw8DoCuVHhGEQb&index=33)

![](./img/etl_vs_elt.png)

**Kimball's Dimensional Modeling:** is an approach used for analytics, that prioritizes understandability and query performance over redundant data. The databases store denormalized data following [star](https://en.wikipedia.org/wiki/Star_schema) or [snowflake](https://en.wikipedia.org/wiki/Snowflake_schema) schemas. The elements of dimensional modeling are:

* **Fact tables**, that store measurements, metrics or facts related to the business process that occurred at some particular moment.

* **Dimensions tables**, which provide context or attributes to the fact tables. [Kleppman (2017)](https://www.google.com.br/books/edition/Designing_Data_Intensive_Applications/p1heDgAAQBAJ?hl=en&gbpv=0) arguments that dimension tables contain the who, what, where, when, how and why of the events registered in the fact tables.

## [DE Zoomcamp 4.1.2 - What is dbt](https://www.youtube.com/watch?v=4eCouvVOJUw&list=PL3MmuxUbc_hJed7dXYoJw8DoCuVHhGEQb&index=34)

Dbt is an acronym for Data Build Tool. It is a tool for the transformation of raw data into a format that allows us to perform analyses and to expose such data to the stakeholders and business managers.

![](./img/dbt.png)

## [DE Zoomcamp 4.2.1 - Start Your dbt Project: BigQuery and dbt Cloud](https://www.youtube.com/watch?v=iMxh6s_wL4Q&list=PL3MmuxUbc_hJed7dXYoJw8DoCuVHhGEQb&index=35)

**Step 1:** [set up dbt cloud with BigQuery](https://github.com/DataTalksClub/data-engineering-zoomcamp/blob/main/week_4_analytics_engineering/dbt_cloud_setup.md). Note: when initializing the cloud project, I informed week4/taxi_rides_ny as the subdirectory in the first step of the project creation.

**Step 2:** open the IDE, create a new branch, click on "Initialize dbt project" and get the result below. Note: it is important to create a new branch, because if we had chosen to work on the master branch we would get stuck in read-only mode.

![](./img/dbt_init.png)

## [DE Zoomcamp 4.3.1 - Build the First dbt Models](https://www.youtube.com/watch?v=UVI30Vxzd6c&list=PL3MmuxUbc_hJed7dXYoJw8DoCuVHhGEQb&index=37)

### dbt models

Dbt models are `SELECT` statements written in a SQL file. An interesting feature of dbt is that we can integrate SQL statements with the Jinja templating language. Jinja code is always written between `{{ ... }}` or `{% ... %}` and can be used to call macros (which are similar to functions in standard programming languages) that allow us to dynamically generate and reuse SQL statements. After compiling the dbt models, the Jinja blocks are substituted by the SQL statement generated by them.

A generic example of a dbt model is:
```sql
{{ config(materialized='table') }}
SELECT * FROM staging.source_table WHERE record_state = 'ACTIVE'
```

The `config()` macro is used to define settings related to materialization (see [this](https://docs.getdbt.com/reference/dbt-jinja-functions/config) and [this](https://docs.getdbt.com/docs/build/materializations) links for more details).

The example above would be compiled by dbt as the following SQL code:
```sql
CREATE TABLE my_schema.my_model as (
    SELECT * FROM staging.source_table WHERE record_state = 'ACTIVE'
)
```

### The FROM clause

In dbt, the `FROM` clause can refer to either sources or seeds.

**Sources** consist of data loaded to our data warehouse. The configuration of the sources is defined through yml files that are saved in the models directory. By using the `source()` macro, dbt automatically resolves the names to the right schema and solves any required dependencies. In our example, we can create the file taxi_rides_ny/models/staging/schema.yml:
```yml
version: 2

sources:
  - name: staging
    database: dtc-de-375514
    schema: trips_data_all

    tables:
      - name: green_tripdata
      - name: yellow_tripdata
```
where database refers to our BigQuery database name, schema is our dataset name, and under `tables` we list the name of our tables that exist in BigQuery. Then, for instance, we can refer to the `green_tripdata` table in our models using:
```sql
FROM {{ source('staging','green_tripdata') }}
```
For more details on sources, see [this link](https://docs.getdbt.com/docs/build/sources).

**Seeds** are csv files stored in our seed directory inside the project, which allows us to effectively version control them. Seeds are recommended for datasets that have infrequent updates.

write schema.yml and stg_green_data.sql under taxi_rides_ny/models/staging

if problems with location see [FAQ](https://docs.google.com/document/d/19bnYs80DwuUimHM65UV3sylsCn2j1vziPOwzBwQrebw/edit#) When running your first dbt model, if it fails with an error: 404 Not found: Dataset was not found in location US

### The FROM clause: ref macro

The `ref()` macro makes it possible for us to reference tables and views that were created from dbt models or dbt seeds. `ref()` resolves the correct schemas and any dependencies. We can use it as follows:
```sql
FROM {{ ref('stg_green_tripdata') }}
```

### Building dbt models

See [stg_green_tripdata.sql](). We can run such a model with the command below.
```
dbt run --select stg_green_tripdata
```

In [stg_green_tripdata.sql](), we can see the following line:
```sql
{{ get_payment_type_description('payment_type') }} as payment_type_description,
```
`get_payment_type_description` consists of a macro that gives us a description of our payment type in plain English. This macro is defined as (see [get_payment_type_description.sql]()):
```sql
{% macro get_payment_type_description(payment_type) -%}

    case {{ payment_type }}
        when 1 then 'Credit card'
        when 2 then 'Cash'
        when 3 then 'No charge'
        when 4 then 'Dispute'
        when 5 then 'Unknown'
        when 6 then 'Voided trip'
    end

{%- endmacro %}
```

Then, after we run our model, we can see the following output in target/compiled/taxi_rider_ny/staging/std_green_tripdata.sql:
```sql
select
    ...
    cast(payment_type as integer) as payment_type,
    case payment_type
        when 1 then 'Credit card'
        when 2 then 'Cash'
        when 3 then 'No charge'
        when 4 then 'Dispute'
        when 5 then 'Unknown'
        when 6 then 'Voided trip'
    end as payment_type_description, 
    cast(congestion_surcharge as numeric) as congestion_surcharge
    ...
```
Note how the macro call was substituted by its code in our SQL statement.
